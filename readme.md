# Покрокове виконання завдання

## Крок 1

Створіть гілку hw5-auth з гілки hw4-validation і виконуйте це завдання в гілці hw5-auth.

## Крок 2

Створіть модель User з такими полями:

name - string, required
email - string, email, unique, required
password - string, required
createdAt - дата створення
updatedAt - дата оновлення

Створіть модель Session з такими полями:

userId - string, required
accessToken - string, required
refreshToken - string, required
accessTokenValidUntil - Date, required
refreshTokenValidUntil - Date, required

## Крок 3

Створіть роут POST /auth/register для реєстрації нового користувача. Тіло запиту має в себе включати наступні властивості:

name - обов’язково
email - обов’язково
password - обов’язково (памʼятайте, що пароль має бути захешованим за допомогою бібліотеки bcrypt)

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/auth.js
Валідацію отриманих даних
Опис контролера для цього роута в файлі src/controllers/auth.js
Створення сервісу в файлі src/services/auth.js
Переконайтеся, що користувач із такою поштою ще не існує в системі, поверніть за допомогою бібілотеки createHttpError 409 помилку в іншому випадку і повідомлення 'Email in use’.
Відповідь сервера, в разі успішного створення нового користувача, має бути зі статусом 201 і містити об’єкт з наступними властивостями:
status — статус відповіді
message — повідомлення про результат виконання операції "Successfully registered a user!"
data — дані створеного користувача (має бути відсутнє поле з паролем!)

## Крок 4

Створіть роут POST /auth/login для аутентифікації користувача. Тіло запиту має в себе включати наступні властивості:

email - обовʼязково
password - обовʼязково

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/auth.js
Валідацію отриманих даних
Опис контролера для цього роута в файлі src/controllers/auth.js
Створення сервісу в файлі src/services/auth.js
Переконайтеся, що користувач із такою поштою та паролем існує в системі, поверніть за допомогою бібілотеки createHttpError 401 помилку в іншому випадку.
Якщо користувача за переданими даними було знайдено, то створіть для нього сессію, в яку запишіть згенеровані access та refresh токени. Стара сесія, за її наявності, має бути видалена. Вкажіть час життя 15 хв для access токену та 30 днів для refresh токену.
Запишіть рефреш токен в cookies, а access токен поверніть в тілі відповіді.
Відповідь сервера, в разі успішного створення нового контакту, має бути зі статусом 200 і містити об’єкт з наступними властивостями:
status — статус відповіді
message — повідомлення про результат виконання операції "Successfully logged in an user!"
data — об'єкт з властивістю accessToken, що містить значення створеного access токена

## Крок 5

Створіть роут POST /auth/refresh для оновлення сесії на основі рефреш токена,

який записаний в cookies.

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/auth.js
Опис контролера для цього роута в файлі src/controllers/auth.js
Створення сервісу в файлі src/services/auth.js
Попередня сесія, за її наявності, має бути видалена, а нова створена за тим самим принципом, що і в POST /auth/login.
Відповідь сервера, в разі успішного створення нового контакту, має бути зі статусом 200 і містити об’єкт з наступними властивостями:
status — статус відповіді
message — повідомлення про результат виконання операції "Successfully refreshed a session!"
data — об'єкт з властивістю accessToken, що містить значення новоствореного access токена

## Крок 6

Створіть роут POST /auth/logoutдля видалення сесії на основі id сесії та токена, який записаний в cookies.

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/auth.js
Опис контролера для цього роута в файлі src/controllers/auth.js
Створення сервісу в файлі src/services/auth.js
Поточна сесія має бути видалена.
Відповідь сервера, в разі успішного логаута, має бути зі статусом 204, без тіла відповіді.

## Крок 7

Створіть middleware authenticate, який буде на основі access токену з заголовку Authorization у вигляді Bearer-токену, визначати користувача і додавати його до обʼєкту запиту(req) у вигляді властивості user. При цьому переконайтеся, що access токен не протермінований, інакше за допомогою бібліотеки createHttpError поверніть помилку зі статусом 401 і повідомленням “Access token expired”.

Застосуйте цей middleware до всіх роутів контактів.

## Крок 8

Розширте модель Contact обовʼязковим полем userId, яке буде вказувати на приналежність контакта певному користувачу.

Змініть логіку роута POST /contacts, щоб при створенні нового контакту також додавалося поле userId. Значення для userId візьміть із req.user.\_id.

Також змініть логіку для всіх інших роутів, які працюють з колекцією контактів, щоб користувачі могли працювати лише з власними контактами. Для цього у сервісних функціях використовуйте методи Mongoose такі як find(), findOne() тощо, щоб мати можливість шукати контакти окрім іншого і за значенням властивості userId.

## Крок 9

Поміняйте гілку, з якої зараз деплоїться ваш проєкт на render.com, на hw5-auth. Переконайтеся, що зміни успішно задеплоєні.

> !Дуже важливо перед здачею дз на перевірку ментору перевіряти роботу вашого задеплоєного додатка на render.com. Якщо, наприклад, при деплої ви забули додати змінні оточення (env), то задеплоєний бекенд не буде працювати. Також перевірте, що всі створені вами маршрути бекенду працюють як очікується згідно з завданням.
